/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package groovyx.acme.text;

import groovy.lang.GroovyShell;
import groovy.lang.Script;
import groovy.lang.Writable;
import groovy.text.Template;
import groovy.text.TemplateEngine;
import org.codehaus.groovy.control.CompilationFailedException;
import java.io.IOException;
import java.io.Reader;
import java.nio.CharBuffer;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import org.codehaus.groovy.runtime.IOGroovyMethods;
import org.codehaus.groovy.runtime.MethodClosure;

/**
 * Processes template source files substituting variables and expressions into placeholders in a template source text to produce the desired output.
 * <br>The template engine uses JSP style &lt;% %&gt; script and &lt;%= %&gt; expression syntax or GString style expressions.
 * <br>Difference from standard groovy.text.TemplateEngine
 * <br>
 * <ul>
 *     <li>template does not need to use screening for characters like '$', '\', '%'</li>
 *     <li>can parse big templates</li>
 *     <li>thread safe</li>
 *     <li>can be chosen the mode of parsing: using JSP like template or GString like template or both</li>
 * </ul>
 */
public class AcmeTemplateEngine extends TemplateEngine {

    final static String MODE_ALL = "&";
    final static String MODE_JSP = "%";
    final static String MODE_SH = "$";
    String mode = MODE_ALL;

    GroovyShell groovyShell = new GroovyShell();

    /**
     * Sets mode of expressions style: JSP style or GString style or both)
     */
    AcmeTemplateEngine setMode(String mode) {
        this.mode = mode;
        return this;
    }

    /**
     * Creating template with input string
     */
    @Override
    public Template createTemplate(String templateText) throws CompilationFailedException, ClassNotFoundException, IOException {
        return new AcmeTemplate(templateText);
    }

    /**
     * Creating template with reader
     */
    @Override
    public Template createTemplate(Reader reader) throws CompilationFailedException, ClassNotFoundException, IOException {
        return new AcmeTemplate(IOGroovyMethods.getText(reader));
    }


    /**
     * Parses the template and creates a result
     */
    class AcmeTemplate implements Template {

        CharBuffer template;
        Class<Script> scriptClass = null;



        public AcmeTemplate(CharSequence templateText) {
            template = CharBuffer.wrap(templateText);
        }


        private Script getScript() throws IllegalAccessException, InstantiationException, IOException {
            if (scriptClass == null) {
                Script script = parse();
                scriptClass = (Class<Script>) script.getClass();
                return script;
            } else return scriptClass.newInstance();
        }



        private Script parse() throws IOException {
            int state = 0;//0 - `<` - 1 - `%` - 2 -'%' - 3 - `>` - 1
            boolean eqFlag = false;
            StringBuffer out = new StringBuffer((int) (template.length() * 0.75));
            char[] cchars = {
                    '<', '%', '%', '>',
                    '$', '{', '}'};

            int index = 0;
            int start = 0; //start of the last block script or default
            out.append("/*autogenerated script start*/\n");
            for (index = 0; index < template.length(); index++) {
                char b = template.get(index);
                switch (state) {
                    case 0: //default
                        if (b == cchars[0] && (mode == MODE_JSP || mode == MODE_ALL)) {
                            state = 1;
                        } else if (b == cchars[4] && (mode == MODE_SH || mode == MODE_ALL)) {
                            state = 5;
                        }
                        // else if( b==cchars[4] ){ state=5; } //comment to disable support of ${} expressions
                        break;
                    case 1: //got `<` from default waiting for `%`
                        if (b == cchars[state]) {
                            state++;
                            if (index - 1 > start) {
                                out.append("\ntemplate.position(" + start + ");");
                                out.append("\nwrite(out, template, " + (index - 1 - start) + ");\n");
                            }
                            start = index + 1;
                        } else {
                            state = 0; //fall back state
                        }
                        break;
                    case 2: //got `%` after `<` : sctipt started from the next byte
                        //println "index=$index state=$state b=`${(char)b}`"
                        if (b == cchars[state]) {
                            state++;
                        } else {
                            if (start == index && b == (char) '=') {
                                out.append("\nwrite(out, ");
                                eqFlag = true;
                            } else {
                                out.append(b);
                            }
                        }
                        break;
                    case 3: //got `%` from script waiting for `>` to go to default state
                        if (b == cchars[state]) {
                            state = 0;
                            if (index + 3 > start) {
                                if (eqFlag) {
                                    out.append(" );");
                                }
                                eqFlag = false;
                                //out.append("\ntemplateStream.skip("+(index-start+3)+");");
                            }
                            start = index + 1;
                        } else {
                            out.append('%');
                            out.append((char) b);
                            state = 2; //fall back state
                        }
                        break;
                    case 5: //got '$' on previous step. waiting for '{'
                        if (b == cchars[state]) {
                            state++;
                            if (index - 1 > start) {
                                out.append("\ntemplate.position(" + start + ");");
                                out.append("\nwrite(out, template, " + (index - 1 - start) + ");\n");
                            }
                            out.append("\nwrite(out, ");
                            start = index + 1;
                        } else {
                            state = 0; //fall back state
                        }
                        break;
                    case 6: //got `}` from script waiting for `>` to go to default state
                        if (b == cchars[state]) {
                            state = 0;
                            if (index + 3 > start) {
                                out.append(" );");
                                //out.append("\ntemplateStream.skip("+(index-start+3)+");");
                            }
                            start = index + 1;
                        } else {
                            out.append((char) b);
                        }
                        break;
                }
            }
            if (state == 0) {
                if (index > start) {
                    out.append("\ntemplate.position(" + start + ");");
                    out.append("\nwrite(out, template, " + (index - start) + ");\n");
                }
            } else {
                throw new RuntimeException("Wrong state=" + state + " at the end of the template file. Close all expressions!");
            }
            out.append("\ntemplate.position(0);");
            out.append("\nout.flush();");
            out.append("\n/*autogenerated script end*/");
            template.position(0);
            String scriptText = out.toString();
            return groovyShell.parse(scriptText, "AcmeTemplate_" + Long.toHexString(template.hashCode()) + ".groovy");
        }


        @Override
        public Writable make() {
            return make(new HashMap());
        }



        public void write(Appendable out, Object data) throws IOException {
            write(out, data, -1);
        }


        public void write(Appendable out, Object data, int chars /*-1: all*/) throws IOException {
            if (data == null || chars == 0) return;
            if (data instanceof CharSequence) {
                CharSequence cs = (CharSequence) data;
                if (chars == -1) chars = cs.length();
                if (chars == 0) return;
                out.append(cs, 0, chars);
                if (cs instanceof CharBuffer) {
                    //if it's a charbuffer move current position
                    ((CharBuffer) cs).position(((CharBuffer) cs).position() + chars);
                }
            } else {
                this.write(out, data.toString(), chars);
            }
        }


        @Override
        public Writable make(Map map) {
            Map bindMap = new LinkedHashMap();
            bindMap.putAll(map);
            bindMap.put("template", template);
            bindMap.put("write", new MethodClosure(this, "write")); //this.&write;
            Writable writable = null;
            try {
                writable = new AcmeTemplateWritable(getScript(), bindMap);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return writable;
        }
    }

}
